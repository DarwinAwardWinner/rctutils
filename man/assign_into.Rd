% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prog_utils.R
\name{assign_into}
\alias{assign_into}
\title{Assign into complex sub-expressions and return the whole object}
\usage{
assign_into(x, expr, value)
}
\arguments{
\item{x}{The object to assign into. (Typically this argument is
delivered via \code{\%\>\%()}.)}

\item{expr}{The left hand side of the assignment operation to be
performed on \code{x}.}

\item{value}{The right hand side of the assignment operation to be
performed.}
}
\value{
The value of \code{x} after performing the assignment.

As usual, \code{x}, the object being passed in, should be
referenced in both \code{expr} and \code{value} as \code{.}. In
fact, \code{expr} *must* contain at least one \code{.}, or else the
object will not be modified. (This is currently not checked.)

Note that this function uses the lazyeval package rather than its
apparent successor, rlang, because rlang doesn't support
interpolating expressions on the left-hand-side of an assignment
operation: https://github.com/r-lib/rlang/issues/212.
}
\description{
Assign into complex sub-expressions and return the whole object
}
\examples{

library(magrittr)

# Returns the entire list, not just the value of x
list(a = 1, b = 2, c = 3) \%>\% assign_into(.$x, 5)

\dontrun{
# A more complex example of how this might be used in the middle of
# a pipeline. Imagine that x is a list of SummarizedExperiment
# objects, and for some reason one of the values in one of the
# assays in one of the objects is wrong and needs to be modified.
x \%>\% assign_into(assays(.[[1]])$counts[3,5], 45) \%>\% ...
}

}
\seealso{
\code{\%\>\%} from the magrittr package.
}
